---
title: "Docker essential commands"
date: "2021-12-17"
---

## Run it with some sauce ;)

#### Run a mysql instance and expose port 3306

Instead of installing a mysql in your host system for development purposes, just use docker to simplify your life:

```sh
docker run -p 3306:3306  --name mysql-sandbox -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7
```

#### Run a temporary mysql instance and expose port 3306

Sometimes its good to have a temporary container (--rm) for some quick test/sandbox:

```sh
docker run --rm -p 3306:3306 --name mysql-sandbox -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7
```

#### Run a bash session from a specific image

Sometimes its useful to have a bash session in your favorite linux to test some commands:

```sh
docker run -it ubuntu /bin/bash
```

#### Run with explicit bind-mount and env-variables

When working on an application, we can use a bind mount to mount our source code into the container to let it see code changes, respond, and let us see the changes [right away](https://docs.docker.com/get-started/06_bind_mounts/): 

```sh
docker run --mount type=bind,source="$(pwd)"/source_file.ext,target=/target_file.ext
   --env-file .env
   -it <image>
   /bin/bash
```

#### Run with a container name, env variables and in detached mode

```sh
docker run 
   --name my-container
   -e MYSQL_ROOT_PASSWORD=my-secret-pw
   -d
   mysql:tag
```

After that, you can log into your container with the exec command referencing it's name:

```sh
 docker exec -it my-container bash
```


----


## Manage what you have :v:

#### Stop all running containers
```sh
docker stop $(docker ps -a -q)
```

#### Delete stopped containers
```sh
docker container prune
```

#### Remove all unused (dangling) volumes. Unused local volumes are those which are not referenced by any containers
```sh
$ docker volume prune
```
 
#### Cleans up dangling volumes, networks, stopped containers and all unused images
```sh
docker system prune -a
```

#### List dangling volumes
```sh
docker volume ls --filter "dangling=true"
```
 
 #### List images with ids and digests
```sh
docker image ls --digests
```

----


## Build what you need :muscle:

#### Build providing a name and build time env-variables
```sh
docker build .
  --tag "name:tag"
  --build-arg APP_HOME=$APP_HOME
```

#### What's name and tag?

A docker image usually has 3 parts: name, tag, and digest.

Names are usually linked to the software the image runs, and tags are usually associated with the release version. The digest is a id that is created during build time by hashing the image contents.

Images can be pulled using name, or name:tag or name@sha256:digest. If we do not specify a version (tag) we will pull the latest.


----


## TODO
#### Create/Connect to a local mysql5.7 sandbox instance

First create a docker container, expose the port to 3008 and give it a name + root pwd:
```bash
docker run -p 127.0.0.1:3308:3306 --name mysql-sandbox -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7
```

Then connect to it using a docker client (to find the internall bridge docker ip use `docker inspect mysql-sandbox`)
```bash
docker run -it --rm mysql:5.7 mysql -h172.17.0.3 -uroot -p
```

By default all containers are created inside the default bridge network and are assigned ips on that network. 
For some unknown reason I was not able to reference containers by name (unless when using compose) and when connecting I used internal ip addresses on the default bridge network.

#### Create a mysql based on a pre-populated volume (exposed at host:3308)
```bash
docker run -p 127.0.0.1:3308:3306
  --name mysql-pre-populated
  -v pre-populated-volume:/var/lib/mysql 
  -e MYSQL_ROOT_PASSWORD=123456
  -d mysql:5.7
```










#### Creating a new mysql from a copied volume

For a quick listing of volumes run:
```sh
$ docker volume ls
```

To know which volumes are being used by which containers run:
```sh
$ docker inspect {container-name} 
```

If using in Linux, copying a volume and using in a new container is pretty straightforward:
https://stackoverflow.com/questions/67567986/copy-docker-volumes

However, for mac we should do it through the docker interface.

First, spin up a mysql instance:
https://hub.docker.com/_/mysql

Use the following to copy the current mysql volume:
```sh
$ docker volume create --name new_volume 
$ docker container run --rm -it \
-v old_volume:/from \
-v new_volume:/to \
alpine ash -c "cd /from ; cp -av . /to"
```

Now spin up a new mysql instance based on the volume created:
```sh
$ docker run -p 127.0.0.1:3308:3306 \
--name mysql-sandbox-copy \
-v copy-col-mysql-sanbox:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql:5.7
```

